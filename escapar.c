#pragma config(Sensor, S1,     Touch,          sensorEV3_Touch)
#pragma config(Sensor, S4,     Sonar,          sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          claw,          tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          left,          tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          right,         tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int distanceToMaintain = 10;
const int distanceCritial = 5;
const int distanceToStartBraking = 45;

int currentDistance = 0;

void close_claw(){
	motor[claw] = 30;
	sleep(300);
	motor[claw] = 0;
}

void turn_a_bit(){
	motor[left] = -30;
	motor[right] = 30;
	sleep(500);
}

void go_backwards(){
	motor[left] = -30;
	motor[right] = -30;
	sleep(500);
}

void go_forward(){
	motor[left] = 30;
	motor[right] = 30;
}

void stop_moving(){
	motor[left] = 0;
	motor[right] = 0;
}

task main()
{
	close_claw();
	while (true)
	{
		//-------------------TOUCH SENSOR-------------------
		// Turn the LED red if the touch sensor is pressed
		if (SensorValue[Touch])
		{
			displayCenteredBigTextLine(4, "Pressed!");
			setLEDColor(ledRed);
			go_backwards();
			turn_a_bit();
		}
		// If it's in a released state, turn the LED green
		else
		{
			displayCenteredBigTextLine(4, "Not Pressed!");
			setLEDColor(ledGreen);
			go_forward();
		}

		//-------------------ULTRASOUND SENSOR--------------------

		if (currentDistance != SensorValue[Sonar]) {
			writeDebugStreamLine("Dist: %3d cm", currentDistance);
		}

		// Read the sensor
		currentDistance = SensorValue[Sonar];

		if (currentDistance > distanceToStartBraking) {
			setLEDColor(ledGreen);
			} else {
			setLEDColor(ledOrange);
		}

		// CONSTANT SPEED
		if (currentDistance > distanceToStartBraking)
		{
			go_forward();
		}

		// diminishing speed
		else if (distanceToStartBraking > currentDistance && currentDistance > distanceToMaintain)
		{
			writeDebugStreamLine("Dist: %3f cm", (20 * pow(currentDistance,0.3) - 30));
			motor[left] = 20 * pow(currentDistance,0.3) - 30;
			motor[right] = -20 * pow(currentDistance,0.3) - 30;
		}

		//parate loco
		else if (distanceToMaintain > currentDistance && currentDistance > distanceCritial)
		{
			turn_a_bit();
		}

	}
}
