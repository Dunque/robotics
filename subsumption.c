#pragma config(Sensor, S1,     Touch,          sensorEV3_Touch)
#pragma config(Sensor, S4,     Sonar,          sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          claw,          tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          left,          tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          right,         tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

TSemaphore semaphore;
const int distToEscape = 10;
const int distToApproach = 50;
int currentDistance = 0;

void close_claw(){
	motor[claw] = 30;
	sleep(300);
	motor[claw] = 0;
}

void turn_a_bit(){
	motor[left] = 30;
	motor[right] = -30;
	sleep(500);
}

void go_backwards(){
	motor[left] = -30;
	motor[right] = -30;
	sleep(1000);
}

void go_forward(){
	motor[left] = 30;
	motor[right] = 30;
}

void stop_moving(){
	motor[left] = 0;
	motor[right] = 0;
}

task escape()
{
	while (true)
	{
		// Read the sensor
		currentDistance = SensorValue[Sonar];

		if (currentDistance < distToEscape || SensorValue[Touch]) {

			semaphoreLock(semaphore);

			if (bDoesTaskOwnSemaphore(semaphore))
			{
				setLEDColor(ledRed);
				go_backwards();
				turn_a_bit();

				semaphoreUnlock(semaphore);
			}

		}
	}
}

task approach_walls()
{
	while (true)
	{
		// Read the sensor
		currentDistance = SensorValue[Sonar];

		if (currentDistance > distToApproach) {

			semaphoreLock(semaphore);

				if (bDoesTaskOwnSemaphore(semaphore))
				{
					setLEDColor(ledOrange);
					go_forward();
					semaphoreUnlock(semaphore);
				}
		}
	}
}

task chase_light()
{

}

task follow_walls()
{
	int currentDist = SensorValue[Sonar];
	int error = 0;
	int derivative = 0;
	float correction = 0;
	int baseSpeed = 30;
	int targetDist = 50;

	float kp = 1;
	float ki = 0;
	float kd = 0.1;

	int lastError = 0;
	int integral = 0;

	while (true)
	{

		semaphoreLock(semaphore);

		if (bDoesTaskOwnSemaphore(semaphore))
		{
			setLEDColor(ledGreen);
			// Read the sensor
			currentDist = SensorValue[Sonar];
			error = targetDist - currentDist;
			integral = error + integral;
			derivative = error + lastError;
			correction = kp*error + ki*integral + kd*derivative;
			motor[right] = baseSpeed - correction;
			motor[left] = baseSpeed + correction;
			lastError = error;

			semaphoreUnlock(semaphore);
		}

;
	}
}

task main()
{
	close_claw();
	semaphoreInitialize(semaphore);

	startTask(escape);
	startTask(approach_walls);
	startTask(follow_walls);

	while(true){
		abortTimeslice();
	}


}
