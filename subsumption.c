#pragma config(Sensor, S1,     Touch,          sensorEV3_Touch)
#pragma config(Sensor, S4,     Sonar,          sensorEV3_Ultrasonic)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Motor,  motorA,          claw,          tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          left,          tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          right,         tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

TSemaphore semaphore;
const int distToEscape = 10;
const int distToApproach = 80;
int currentDistance = 0;
int lockTasks[4] = {0, 0, 0, 0};
int light_searching = 0;

void close_claw(){
	motor[claw] = 30;
	sleep(300);
	motor[claw] = 0;
}

void turn_a_bit(){
	motor[left] = 30;
	motor[right] = -30;
	sleep(500);
}

void turnRight(){
	motor[left] = 30;
	motor[right] = -30;
	sleep(300);
	motor[left] = 0;
	motor[right] = 0;
}

void turnLeft(){
	motor[left] = -30;
	motor[right] = 30;
	sleep(300);
	motor[left] = 0;
	motor[right] = 0;
}


void go_backwards(){
	motor[left] = -30;
	motor[right] = -30;
	sleep(1000);
}

void go_forward(){
	motor[left] = 30;
	motor[right] = 30;
}

int * searchLight(long redValue, long greenValue, long blueValue){
	static int  index_val[2];

	float discard;
	float colorAmbient[3] = {0, 0, 0};
	//Mundo real:
	discard = getColorAmbient(colorSensor);
	//Simulacion:
	//getColorRGB(colorSensor, redValue, greenValue, blueValue);
	//colorAmbient[0] = redValue;
	sleep(100);

	turnRight();
	sleep(200);
	colorAmbient[0] = getColorAmbient(colorSensor);
	//getColorRGB(colorSensor, redValue, greenValue, blueValue);
	//colorAmbient[0] = redValue;
	sleep(200);

	turnLeft();
	sleep(200);
	colorAmbient[1] = getColorAmbient(colorSensor);
	//getColorRGB(colorSensor, redValue, greenValue, blueValue);
	//colorAmbient[1] = redValue;
	sleep(200);

	turnLeft();
	sleep(200);
	colorAmbient[2] = getColorAmbient(colorSensor);
	//getColorRGB(colorSensor, redValue, greenValue, blueValue);
	//colorAmbient[2] = redValue;
	sleep(200);

	//Sort greatest direction influence
	int largest_index = 1;
	for (int i = 0; i < 3; i++) {
		if (colorAmbient[i] > colorAmbient[largest_index]){
			largest_index = i;
		}
	}

	//Center robot
	turnRight();
	index_val[0] = largest_index;
	index_val[1] = colorAmbient[largest_index];
	return index_val;
}

void lock(int *locks) {
	semaphoreLock(semaphore);
	lockTasks = *locks;
}

void unlock() {
	if (bDoesTaskOwnSemaphore(semaphore))
	{
		semaphoreUnlock(semaphore);
	}
}

task escape()
{
	while (true)
	{
		// Read the sensor
		currentDistance = SensorValue[Sonar];

		if (currentDistance < distToEscape || SensorValue[Touch]) {
			int lk[4] = {0,1,1,1};
			lock(lk);

			setLEDColor(ledRed);
			go_backwards();
			turn_a_bit();

			unlock();
		}
	}
}

task chase_light()
{
	long redValue = 0;
	long greenValue = 0;
	long blueValue = 0;

	int direction; //0-Right 1-Center 2-Left
	int max_val = 0;

	float initialColorAmbient = getColorAmbient(colorSensor);
	//getColorRGB(colorSensor, redValue, greenValue, blueValue);
	//float initialColorAmbient = redValue;

	while(true){
		light_searching = 1;
		if(lockTasks[1] == 0){
			int lk[4] = {0,0,1,1};
			lock(lk);

			setLEDColor(ledGreenFlash);
			int * dir_light = searchLight(redValue, greenValue, blueValue);
			direction = dir_light[0];
			max_val = dir_light[1];

			//writeDebugStreamLine("max_val %d initialColor %d dir %d", max_val, initialColorAmbient, direction);
			if (max_val > initialColorAmbient){
				switch(direction){
					case 0:
						turnRight();
						break;
					case 1:
						break;
					case 2:
						turnLeft();
					 	break;
				}
				go_forward();
				sleep(600);
			}
			unlock();
		}
		light_searching = 0;
		sleep(3000);
	}

}

task follow_walls()
{
	int currentDist = SensorValue[Sonar];
	int error = 0;
	int derivative = 0;
	float correction = 0;
	int baseSpeed = 30;
	int targetDist = 50;

	float kp = 1;
	float ki = 0;
	float kd = 0.1;

	int lastError = 0;
	int integral = 0;

	while (true)
	{
		if (lockTasks[2] == 0) {
			int lk[4] = {0,0,0,1};
			lock(lk);

			while(currentDistance < distToApproach && !light_searching) {
				setLEDColor(ledGreen);
				// Read the sensor
				currentDist = SensorValue[Sonar];
				error = targetDist - currentDist;
				integral = error + integral;
				derivative = error + lastError;
				correction = kp*error + ki*integral + kd*derivative;
				motor[right] = baseSpeed - correction;
				motor[left] = baseSpeed + correction;
				lastError = error;
			}

			unlock();
		}
	}
}

task approach_walls()
{
	while (true)
	{
		// Read the sensor
		currentDistance = SensorValue[Sonar];

		if (currentDistance > distToApproach && lockTasks[3] == 0) {

			int lk[4] = {0,0,0,0};
			lock(lk);

			setLEDColor(ledOrange);
			go_forward();
			sleep(600);

			unlock();
		}
	}
}

task main()
{
	close_claw();
	semaphoreInitialize(semaphore);

	startTask(escape);
	startTask(chase_light);
	startTask(follow_walls);
	startTask(approach_walls);

	while(true){
		abortTimeslice();
	}


}
